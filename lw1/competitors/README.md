## Конспект
### Описание различий лексики, синтаксиса и семантики языков Python, C++


#### 1. Синтаксис циклов, ветвлений, блоков кода

##### Python: 
* Отсутствие фигурных скобок — блоки кода определяются только отступами
* if, for, while — без скобок, но с : в конце
* Нет switch, но есть match — умное ветвление по структуре данных.
* else можно писать даже после for/while — сработает, если не было break

##### C++:
* Блоки — { }, отступы не важны.
* Всё, что в условии — в скобках: if (x>0) { ... }.
* Есть switch, но только для целых чисел и enum.
* Цикл for часто выглядит как for (int i = 0; i < n; ++i).


```Python похож на английский текст, C++ — на инструкцию процессору.```

#### 2. Типы переменных

##### Python: 
* Типы не пишут — интерпретатор сам понимает, что есть что.
* Можно подсказать: x: int = 5 — но это только для программистов и инструментов (вроде mypy), код от этого не меняется.

##### C++:
* Тип обязательно указывают: int x = 5;, string s = "hi";.
* Можно заставить компилятор угадать: auto x = 5; он сам поставит int.

#### 3. Типы данных

|Столбец 1|Столбец 2|Столбец 3|
|:--------|:-------:|:--------|
|Целые числа|Любые, хоть миллион цифр — всё считается|Только до ~9·10¹⁸ ( long long), дальше — переполнение|
|Дроби|float— с плавающей точкой, как в калькуляторе|float(менее точно),double(точнее),long double(ещё точнее)|
|Строки|"Привет"— сразу Unicode, нельзя менять символы|"Привет"— этоchar[], без Unicode «из коробки»; строки можно менять|
|Списки/массивы|list = [1, 2, 3] — растёт сам, хранит что угодно|vector<int> v = {1,2,3};— только один тип, размер можно менять, array- нельзя|
|Словари| Тип не указывается d = {"a": 1}| Для ключа и значения тип указываетсяunordered_map<string, int> d = {{"a",1}};|

### 4. Операторы

###### Схожесть:
  __+ - * / % == != < > && || !__
###### Различия:

Python:
* and, or, not (вместо &&, ||, !)
* // — деление нацело (7 // 3 = 2)
* ** — возведение в степень (2 ** 3 = 8)
* in — проверка вхождения: if "a" in s:
* is — «один и тот же объект?», а не «равны?»
C++:
* ++i, i++ — увеличить на 1
* a ? b : c — короткая запись if-else
* <<, >> — в потоках: cout << "hi";


### 5. Функции
Python:

```python
def add(a, b):
    return a + b
```
* Можно не указывать типы.
* Можно передать любые аргументы — функция сама разберётся.
* Можно добавить *args и **kwargs — «остальное положите сюда».

C++:

```cpp
int add(int a, int b) {
    return a + b;
}
```
* Типы аргументов и результата — обязательно.
* Можно сделать «универсальную» функцию через шаблоны:
  
```cpp
template<typename T>
T add(T a, T b) { return a + b; }
```
```Python — гибко: «передай что хочешь». C++ — чётко: «передай именно так».```

### 6. Свои структуры (классы)

Python

``` python
class Person:
    def __init__(self, name):
        self.name = name
```

* Можно добавить любое поле в любой момент (p.age = 30).
* Наследование — просто: class Student(Person): ...

C++:

``` cpp
struct Person {
    string name;
    Person(string n) : name(n) {}
};
```
* Все поля — только те, что написаны в struct/class.
* Наследование есть, но с осторожностью — легко запутаться.

```Python — как блокнот: пишешь, что в голову пришло. C++ — как чертёж: сначала всё спроектируй```


### 7. Память
Python:
* Всё — автоматически. Закончился срок жизни переменной? — Python сам почистит.
* Не нужно думать о том, где лежит объект.

C++:
* По умолчанию — «на стеке»: автоматически удаляется при выходе из { }.
* Если нужно дольше — new → но тогда обязательно delete, иначе утечка.
* Чтобы не забыть — используют unique_ptr, shared_ptr («умные указатели»).


### 8. Ошибки
Python:
* Если что-то пошло не так:
``` python
   raise Exception("...")
```
* Ловим:
``` python
try:
    danger()
except ValueError as e:
    print("Ошибка:", e)
```

C++:
```cpp
 throw std::runtime_error("...");
 ```
* Ловим:
```cpp
try {
    danger();
} catch (const std::exception& e) {
    std::cout << "Ошибка: " << e.what();
}
 ```